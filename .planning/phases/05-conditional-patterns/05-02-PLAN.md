---
phase: 05-conditional-patterns
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - "template/custom_components/[[ project_domain ]]/config_flow.py.jinja"
  - "template/custom_components/[[ project_domain ]]/[% if use_multi_step_config_flow %]config_flow_multi_step.py[% endif %].jinja"
  - "template/custom_components/[[ project_domain ]]/[% if use_secondary_coordinator %]coordinator_secondary.py[% endif %].jinja"
  - "template/custom_components/[[ project_domain ]]/const.py.jinja"
  - "template/custom_components/[[ project_domain ]]/strings.json.jinja"
  - "template/custom_components/[[ project_domain ]]/translations/en.json.jinja"
autonomous: true
requirements:
  - COND-03
  - COND-04

must_haves:
  truths:
    - "config_flow.py.jinja contains conditional blocks that render either single-step or multi-step flow based on use_multi_step_config_flow flag"
    - "Multi-step flow splits user/credentials into two steps with self._data accumulation and proper unique_id/validation in last step"
    - "config_flow_multi_step.py stub file is deleted (dead code — HA only discovers config_flow.py)"
    - "coordinator_secondary.py stub replaced with working SecondaryCoordinator using independent poll interval"
    - "strings.json and translations/en.json conditionally include credentials step when multi-step is enabled"
    - "const.py includes DEFAULT_SECONDARY_SCAN_INTERVAL = 300"
  artifacts:
    - path: "template/custom_components/[[ project_domain ]]/config_flow.py.jinja"
      provides: "Single-step or multi-step config flow variant via Jinja2 conditional blocks"
      contains: "use_multi_step_config_flow"
    - path: "template/custom_components/[[ project_domain ]]/[% if use_secondary_coordinator %]coordinator_secondary.py[% endif %].jinja"
      provides: "Secondary DataUpdateCoordinator with independent poll interval"
      contains: "TemplateSecondaryCoordinator"
    - path: "template/custom_components/[[ project_domain ]]/const.py.jinja"
      provides: "DEFAULT_SECONDARY_SCAN_INTERVAL constant"
      contains: "DEFAULT_SECONDARY_SCAN_INTERVAL"
    - path: "template/custom_components/[[ project_domain ]]/strings.json.jinja"
      provides: "Conditional credentials step translations"
      contains: "credentials"
    - path: "template/custom_components/[[ project_domain ]]/translations/en.json.jinja"
      provides: "Conditional credentials step translations"
      contains: "credentials"
  key_links:
    - from: "config_flow.py.jinja"
      to: "copier.yml"
      via: "use_multi_step_config_flow boolean flag controls which class body renders"
      pattern: "use_multi_step_config_flow"
    - from: "coordinator_secondary.py.jinja"
      to: "const.py.jinja"
      via: "DEFAULT_SECONDARY_SCAN_INTERVAL import"
      pattern: "from .const import.*DEFAULT_SECONDARY_SCAN_INTERVAL"
    - from: "coordinator_secondary.py.jinja"
      to: "api.py.jinja"
      via: "ApiClient import for independent data fetching"
      pattern: "from .api import ApiClient"
---

<objective>
Implement multi-step config flow variant (inline in config_flow.py) and secondary coordinator template.

Purpose: Add the multi-step config flow as conditional blocks inside the existing config_flow.py.jinja (not as a separate file, since HA only discovers config_flow.py). Fill the secondary coordinator stub with a working DataUpdateCoordinator subclass with its own poll interval. Update strings/translations for the credentials step.

Output: Updated config_flow.py.jinja with conditional multi-step variant, filled coordinator_secondary.py.jinja, updated const.py/strings/translations, and deleted dead config_flow_multi_step.py stub.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-conditional-patterns/05-RESEARCH.md

# Existing files to modify
@template/custom_components/[[ project_domain ]]/config_flow.py.jinja
@template/custom_components/[[ project_domain ]]/const.py.jinja
@template/custom_components/[[ project_domain ]]/coordinator.py.jinja
@template/custom_components/[[ project_domain ]]/strings.json.jinja
@template/custom_components/[[ project_domain ]]/translations/en.json.jinja
@template/custom_components/[[ project_domain ]]/api.py.jinja
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inline multi-step config flow into config_flow.py.jinja and update translations</name>
  <files>
    template/custom_components/[[ project_domain ]]/config_flow.py.jinja
    template/custom_components/[[ project_domain ]]/[% if use_multi_step_config_flow %]config_flow_multi_step.py[% endif %].jinja
    template/custom_components/[[ project_domain ]]/strings.json.jinja
    template/custom_components/[[ project_domain ]]/translations/en.json.jinja
  </files>
  <action>
    **Step 1: Modify config_flow.py.jinja to include conditional multi-step variant.**

    The existing config_flow.py.jinja has a single-step `TemplateConfigFlow` class. Add `[% if use_multi_step_config_flow %]` / `[% else %]` / `[% endif %]` blocks around the differing parts. The structure should be:

    - Common preamble (imports, _LOGGER, CannotConnect/InvalidAuth classes, _async_validate_connection) stays OUTSIDE any conditional block
    - The `STEP_USER_DATA_SCHEMA` definition differs between single-step and multi-step:
      - Single-step (existing): `{CONF_HOST, CONF_PORT, CONF_API_KEY}` all in one schema
      - Multi-step: `STEP_USER_DATA_SCHEMA = vol.Schema({CONF_HOST, CONF_PORT})` (step 1), `STEP_CREDENTIALS_SCHEMA = vol.Schema({CONF_API_KEY})` (step 2)
    - Wrap the schema definitions in `[% if use_multi_step_config_flow %]` ... `[% else %]` ... `[% endif %]`
    - The `TemplateConfigFlow` class body differs:
      - Single-step: current `async_step_user` (validates everything in one step)
      - Multi-step: `__init__` with `self._data = {}`, `async_step_user` that stores data and returns `await self.async_step_credentials()`, `async_step_credentials` that accumulates data, sets unique_id, validates, creates entry
    - Wrap the class body methods in `[% if use_multi_step_config_flow %]` ... `[% else %]` ... `[% endif %]`
    - The `async_get_options_flow` staticmethod and `OptionsFlowHandler` class remain UNCHANGED (outside conditionals)
    - Multi-step flow pattern from research:
      ```python
      def __init__(self) -> None:
          self._data: dict[str, Any] = {}

      async def async_step_user(self, user_input=None):
          if user_input is not None:
              self._data.update(user_input)
              return await self.async_step_credentials()
          return self.async_show_form(step_id="user", data_schema=STEP_USER_DATA_SCHEMA, errors={})

      async def async_step_credentials(self, user_input=None):
          errors = {}
          if user_input is not None:
              self._data.update(user_input)
              await self.async_set_unique_id(f"{self._data[CONF_HOST]}:{self._data[CONF_PORT]}")
              self._abort_if_unique_id_configured()
              try:
                  await _async_validate_connection(self.hass, self._data)
              except CannotConnect:
                  errors["base"] = "cannot_connect"
              except InvalidAuth:
                  errors["base"] = "invalid_auth"
              except Exception:
                  _LOGGER.exception("Unexpected exception")
                  errors["base"] = "unknown"
              else:
                  return self.async_create_entry(title=self._data[CONF_HOST], data=self._data)
          return self.async_show_form(step_id="credentials", data_schema=STEP_CREDENTIALS_SCHEMA, errors=errors)
      ```

    CRITICAL: In the multi-step `async_step_user`, do NOT set unique_id or validate connection — only collect host/port and chain to credentials. unique_id and validation happen in `async_step_credentials` (after ALL data collected). This follows research anti-pattern guidance.

    **Step 2: DELETE the dead stub file** `[% if use_multi_step_config_flow %]config_flow_multi_step.py[% endif %].jinja`. This file is unreachable by HA (HA only loads config_flow.py). Use `rm` to delete it.

    **Step 3: Update strings.json.jinja** to conditionally include the credentials step:
    Add after the `"user"` step block, inside the `"step"` object:
    ```
    [% if use_multi_step_config_flow %]
      ,"credentials": {
        "title": "Authentication",
        "description": "Enter your API credentials.",
        "data": {
          "api_key": "API Key"
        }
      }
    [% endif %]
    ```
    Note the leading comma BEFORE the key — it is placed inside the conditional so that when false, the JSON remains valid with just the "user" step. When true, the comma + credentials entry is appended.

    Also, when multi-step is enabled, the "user" step should NOT include "api_key" in its data (since api_key moves to credentials step). Wrap the api_key line in the user step data with a conditional:
    ```
    [% if not use_multi_step_config_flow %]
          ,"api_key": "API Key"
    [% endif %]
    ```

    **Step 4: Update translations/en.json.jinja** with identical changes as strings.json.jinja (same structure, same conditional blocks).
  </action>
  <verify>
    1. Delete confirmation: `ls` the template directory and confirm config_flow_multi_step.py stub is gone
    2. Render check: mentally trace `config_flow.py.jinja` with `use_multi_step_config_flow=false` — should produce the EXACT same output as the current single-step file (no regressions)
    3. Render check: mentally trace with `use_multi_step_config_flow=true` — should produce two-step flow with __init__, async_step_user (host/port only), async_step_credentials (api_key + validation)
    4. Verify strings.json.jinja produces valid JSON in both conditional states
    5. Verify translations/en.json.jinja matches strings.json.jinja structure
  </verify>
  <done>
    config_flow.py.jinja contains conditional blocks rendering single-step (default) or multi-step (when use_multi_step_config_flow=true) config flow. Dead config_flow_multi_step.py stub deleted. strings.json and translations/en.json conditionally include credentials step with api_key field. Single-step variant is byte-for-byte identical to pre-edit output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement secondary coordinator and add const</name>
  <files>
    template/custom_components/[[ project_domain ]]/[% if use_secondary_coordinator %]coordinator_secondary.py[% endif %].jinja
    template/custom_components/[[ project_domain ]]/const.py.jinja
  </files>
  <action>
    Replace the coordinator_secondary.py stub with a complete secondary DataUpdateCoordinator following the primary coordinator pattern from coordinator.py.jinja but with these differences:

    ```python
    """Secondary DataUpdateCoordinator for the [[ project_name ]] integration."""

    from __future__ import annotations

    import logging
    from datetime import timedelta
    from typing import Any

    from homeassistant.config_entries import ConfigEntry
    from homeassistant.const import CONF_API_KEY, CONF_HOST, CONF_PORT
    from homeassistant.core import HomeAssistant
    from homeassistant.helpers.aiohttp_client import async_get_clientsession
    from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed

    from .api import ApiClient, CannotConnectError
    from .const import DEFAULT_SECONDARY_SCAN_INTERVAL, DOMAIN

    _LOGGER = logging.getLogger(__name__)


    class TemplateSecondaryCoordinator(DataUpdateCoordinator[dict[str, Any]]):
        """Secondary coordinator for slower-changing data."""

        config_entry: ConfigEntry

        def __init__(self, hass: HomeAssistant, entry: ConfigEntry) -> None:
            """Initialize the secondary coordinator."""
            super().__init__(
                hass,
                _LOGGER,
                name=f"{DOMAIN}_secondary",
                update_interval=timedelta(seconds=DEFAULT_SECONDARY_SCAN_INTERVAL),
            )
            self.config_entry = entry
            session = async_get_clientsession(hass)
            self.client = ApiClient(
                host=entry.data[CONF_HOST],
                port=entry.data[CONF_PORT],
                api_key=entry.data[CONF_API_KEY],
                session=session,
            )

        async def _async_update_data(self) -> dict[str, Any]:
            """Fetch data from the service."""
            try:
                return await self.client.async_get_data()
            except CannotConnectError as err:
                raise UpdateFailed(f"Secondary coordinator error: {err}") from err
    ```

    Key differences from primary coordinator:
    - Class name: `TemplateSecondaryCoordinator` (not `TemplateCoordinator`)
    - Coordinator name: `f"{DOMAIN}_secondary"` (not just `DOMAIN`)
    - Update interval: `DEFAULT_SECONDARY_SCAN_INTERVAL` (not `DEFAULT_SCAN_INTERVAL`) — typically 300s vs 30s
    - Own `ApiClient` instance (not shared — per research recommendation, avoids shared state between concurrent refreshes)

    Update const.py.jinja to add `DEFAULT_SECONDARY_SCAN_INTERVAL = 300` after `DEFAULT_SCAN_INTERVAL = 30`. This constant is always present (harmless if unused, avoids conditional const imports per research recommendation).
  </action>
  <verify>
    1. Verify coordinator_secondary.py.jinja has valid Python structure (class inherits DataUpdateCoordinator, has __init__ and _async_update_data)
    2. Verify const.py.jinja contains both DEFAULT_SCAN_INTERVAL = 30 and DEFAULT_SECONDARY_SCAN_INTERVAL = 300
    3. Verify coordinator_secondary imports DEFAULT_SECONDARY_SCAN_INTERVAL from .const (not hardcoded)
    4. Verify coordinator_secondary creates its OWN ApiClient (not shared with primary)
  </verify>
  <done>
    coordinator_secondary.py.jinja contains a working TemplateSecondaryCoordinator with independent 300s poll interval and its own ApiClient. const.py.jinja has DEFAULT_SECONDARY_SCAN_INTERVAL = 300.
  </done>
</task>

</tasks>

<verification>
1. config_flow.py.jinja renders the original single-step flow when use_multi_step_config_flow=false (no regression)
2. config_flow.py.jinja renders a two-step flow (user + credentials) when use_multi_step_config_flow=true
3. config_flow_multi_step.py stub is deleted from the template directory
4. strings.json.jinja and translations/en.json.jinja conditionally include credentials step data
5. coordinator_secondary.py.jinja has working TemplateSecondaryCoordinator with DEFAULT_SECONDARY_SCAN_INTERVAL
6. const.py.jinja has the new constant
</verification>

<success_criteria>
- Multi-step config flow is inlined in config_flow.py.jinja via [% if %] blocks — no separate file
- Dead config_flow_multi_step.py stub removed
- Secondary coordinator provides TemplateSecondaryCoordinator class importable by __init__.py
- Both conditional modules follow established codebase patterns (import style, error handling, coordinator structure)
</success_criteria>

<output>
After completion, create `.planning/phases/05-conditional-patterns/05-02-SUMMARY.md`
</output>
