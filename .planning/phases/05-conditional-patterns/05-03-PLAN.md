---
phase: 05-conditional-patterns
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
  - 05-02
files_modified:
  - "template/custom_components/[[ project_domain ]]/__init__.py.jinja"
autonomous: true
requirements:
  - COND-05

must_haves:
  truths:
    - "__init__.py has conditional import blocks for websocket, services, and secondary coordinator modules"
    - "__init__.py async_setup calls async_setup_websocket and async_register_services conditionally"
    - "__init__.py async_setup_entry creates and stores secondary coordinator conditionally"
    - "Data dataclass conditionally includes coordinator_secondary field"
    - "Copier smoke test passes with all four conditional features enabled AND with all disabled"
  artifacts:
    - path: "template/custom_components/[[ project_domain ]]/__init__.py.jinja"
      provides: "Conditional wiring for all four feature sets"
      contains: "use_websocket"
    - path: "template/custom_components/[[ project_domain ]]/__init__.py.jinja"
      provides: "Conditional wiring for all four feature sets"
      contains: "use_services"
    - path: "template/custom_components/[[ project_domain ]]/__init__.py.jinja"
      provides: "Conditional wiring for all four feature sets"
      contains: "use_secondary_coordinator"
  key_links:
    - from: "__init__.py.jinja"
      to: "websocket.py.jinja"
      via: "conditional import of async_setup_websocket"
      pattern: "from .websocket import async_setup_websocket"
    - from: "__init__.py.jinja"
      to: "services.py.jinja"
      via: "conditional import of async_register_services"
      pattern: "from .services import async_register_services"
    - from: "__init__.py.jinja"
      to: "coordinator_secondary.py.jinja"
      via: "conditional import of TemplateSecondaryCoordinator"
      pattern: "from .coordinator_secondary import TemplateSecondaryCoordinator"
---

<objective>
Wire all conditional modules into __init__.py and verify the complete template with a copier smoke test.

Purpose: Connect the WebSocket, services, and secondary coordinator modules into __init__.py using minimal [% if %] blocks. Then validate that copier copy produces correct output with all features on and all features off.

Output: Updated __init__.py.jinja with conditional wiring and verified end-to-end copier smoke test.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-conditional-patterns/05-RESEARCH.md
@.planning/phases/05-conditional-patterns/05-01-SUMMARY.md
@.planning/phases/05-conditional-patterns/05-02-SUMMARY.md

# Existing files to modify
@template/custom_components/[[ project_domain ]]/__init__.py.jinja
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conditional import and wiring blocks to __init__.py.jinja</name>
  <files>
    template/custom_components/[[ project_domain ]]/__init__.py.jinja
  </files>
  <action>
    Add minimal `[% if flag %]...[% endif %]` blocks to __init__.py.jinja for three conditional features: websocket, services, secondary coordinator. Multi-step config flow does NOT require __init__.py changes (it is handled entirely within config_flow.py).

    **1. Conditional imports** — add AFTER the existing `from .coordinator import TemplateCoordinator` line:
    ```
    [% if use_websocket %]
    from .websocket import async_setup_websocket
    [% endif %]
    [% if use_services %]
    from .services import async_register_services
    [% endif %]
    [% if use_secondary_coordinator %]
    from .coordinator_secondary import TemplateSecondaryCoordinator
    [% endif %]
    ```

    **2. Data dataclass expansion** — add a conditional field to the dataclass after `coordinator: TemplateCoordinator`:
    ```python
    @dataclass
    class [[ PascalDomain ]]Data:
        """Data for the [[ project_name ]] integration."""

        coordinator: TemplateCoordinator
    [% if use_secondary_coordinator %]
        coordinator_secondary: TemplateSecondaryCoordinator
    [% endif %]
    ```
    (Where `[[ PascalDomain ]]` is the existing `[[ project_domain | replace('_', ' ') | title | replace(' ', '') ]]` filter chain already used in the file.)

    **3. async_setup wiring** — add calls inside `async_setup()` AFTER the Lovelace auto-registration try/except block and BEFORE `return True`:
    ```python
    [% if use_websocket %]
        async_setup_websocket(hass)
    [% endif %]
    [% if use_services %]
        async_register_services(hass)
    [% endif %]
    ```
    CRITICAL: WebSocket and services are registered in `async_setup` (domain-level, called once), NOT `async_setup_entry` (per-entry). This prevents duplicate registration when multiple config entries exist. Per research Pitfall 2 and Pitfall 3.

    **4. async_setup_entry expansion** — add secondary coordinator initialization AFTER `coordinator = TemplateCoordinator(...)` and `await coordinator.async_config_entry_first_refresh()` but BEFORE `entry.runtime_data = ...`:
    ```python
    [% if use_secondary_coordinator %]
        coordinator_secondary = TemplateSecondaryCoordinator(hass, entry)
        await coordinator_secondary.async_config_entry_first_refresh()
    [% endif %]
    ```

    **5. runtime_data assignment expansion** — the `entry.runtime_data = ...` line must conditionally include coordinator_secondary:
    ```python
    [% if use_secondary_coordinator %]
        entry.runtime_data = [[ PascalDomain ]]Data(
            coordinator=coordinator,
            coordinator_secondary=coordinator_secondary,
        )
    [% else %]
        entry.runtime_data = [[ PascalDomain ]]Data(coordinator=coordinator)
    [% endif %]
    ```

    **Anti-pattern to avoid:** Do NOT put any feature logic in __init__.py. It is a wiring file only — imports and function calls. All logic lives in the conditional modules.
  </action>
  <verify>
    1. Count [% if %] blocks — should be exactly 7 conditional blocks (3 imports, 2 async_setup calls, 1 secondary coordinator init, 1 runtime_data if/else)
    2. Trace with all flags=false: output should be identical to current __init__.py.jinja output (no regressions)
    3. Trace with all flags=true: output should have all imports, async_setup calls, secondary coordinator init, and expanded runtime_data
    4. Verify no feature logic leaked into __init__.py — only imports and one-line function calls
  </verify>
  <done>
    __init__.py.jinja has minimal conditional blocks for websocket, services, and secondary coordinator. Domain-level setup (websocket, services) in async_setup. Per-entry setup (secondary coordinator) in async_setup_entry. Data dataclass conditionally expanded.
  </done>
</task>

<task type="auto">
  <name>Task 2: Copier smoke test — all features ON and all features OFF</name>
  <files>
    (no files modified — verification only)
  </files>
  <action>
    Run two copier smoke tests to validate the complete Phase 5 implementation. Must advance git tag 0.1.0 to HEAD first (copier uses tagged version for file list).

    **Pre-step: Advance git tag**
    ```bash
    git tag -f 0.1.0 HEAD
    ```

    **Test 1: All features OFF (default)**
    ```bash
    cd /tmp && rm -rf test-off && mkdir test-off
    copier copy --defaults --data project_domain=smoke_test --data author_name=test /home/dab/Projects/ha-hacs-template test-off
    ```
    Verify:
    - `custom_components/smoke_test/websocket.py` does NOT exist
    - `custom_components/smoke_test/services.py` does NOT exist
    - `custom_components/smoke_test/services.yaml` does NOT exist
    - `custom_components/smoke_test/coordinator_secondary.py` does NOT exist
    - `custom_components/smoke_test/config_flow_multi_step.py` does NOT exist
    - `custom_components/smoke_test/__init__.py` does NOT contain "websocket", "services", "secondary"
    - `custom_components/smoke_test/config_flow.py` contains single-step flow (no `async_step_credentials`)
    - `custom_components/smoke_test/manifest.json` dependencies is `["frontend"]` (no websocket_api)
    - All Python files parse with `python3 -c "import ast; ast.parse(open(f).read())"`
    - All JSON files parse with `python3 -c "import json; json.load(open(f))"`
    - strings.json has NO "credentials" step
    - translations/en.json has NO "credentials" step

    **Test 2: All features ON**
    ```bash
    cd /tmp && rm -rf test-on && mkdir test-on
    copier copy --defaults --data project_domain=smoke_test --data author_name=test --data use_websocket=true --data use_services=true --data use_secondary_coordinator=true --data use_multi_step_config_flow=true /home/dab/Projects/ha-hacs-template test-on
    ```
    Verify:
    - `custom_components/smoke_test/websocket.py` EXISTS and parses as valid Python
    - `custom_components/smoke_test/services.py` EXISTS and parses as valid Python
    - `custom_components/smoke_test/services.yaml` EXISTS
    - `custom_components/smoke_test/coordinator_secondary.py` EXISTS and parses as valid Python
    - `custom_components/smoke_test/config_flow_multi_step.py` does NOT exist (stub deleted)
    - `custom_components/smoke_test/__init__.py` contains "async_setup_websocket", "async_register_services", "TemplateSecondaryCoordinator"
    - `custom_components/smoke_test/__init__.py` parses as valid Python
    - `custom_components/smoke_test/config_flow.py` contains `async_step_credentials` (multi-step)
    - `custom_components/smoke_test/config_flow.py` parses as valid Python
    - `custom_components/smoke_test/manifest.json` dependencies includes "websocket_api"
    - `custom_components/smoke_test/manifest.json` parses as valid JSON
    - strings.json has "credentials" step with api_key field
    - translations/en.json has "credentials" step with api_key field
    - All other Python files still parse
    - No Jinja2 artifacts remain (no `[[`, `[%`, `]]`, `%]` in any generated file)

    If any check fails, identify the root cause file, fix it, re-tag, and re-run the failing test.
  </action>
  <verify>
    Both smoke tests pass all checks. Print a summary table of all checks with PASS/FAIL for each.
  </verify>
  <done>
    Copier smoke test confirms: all-features-OFF generates clean default project (no conditional files, no conditional code in __init__.py); all-features-ON generates project with all four conditional modules present, wired into __init__.py, multi-step config flow active, websocket_api in manifest, credentials step in strings/translations. All Python files parse. All JSON files parse. No Jinja2 artifacts.
  </done>
</task>

</tasks>

<verification>
1. __init__.py.jinja has exactly 7 conditional blocks for three features
2. No feature logic in __init__.py — only imports and one-line calls
3. Domain-level setup (websocket, services) in async_setup; per-entry setup (secondary coordinator) in async_setup_entry
4. Copier copy with defaults produces identical output to pre-Phase-5 template (no regressions)
5. Copier copy with all features ON produces complete project with all conditional modules and wiring
6. All generated Python files have valid syntax; all JSON files parse correctly
</verification>

<success_criteria>
- __init__.py.jinja correctly wires all three conditional modules using minimal [% if %] blocks
- Two copier smoke tests pass (all-off, all-on) confirming end-to-end template correctness
- Git tag 0.1.0 advanced to HEAD for copier version anchoring
</success_criteria>

<output>
After completion, create `.planning/phases/05-conditional-patterns/05-03-SUMMARY.md`
</output>
