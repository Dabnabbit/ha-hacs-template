---
phase: 03-backend-core
plan: 03
type: execute
wave: 2
depends_on:
  - 03-01
  - 03-02
files_modified:
  - template/custom_components/[[ project_domain ]]/config_flow.py.jinja
  - template/custom_components/[[ project_domain ]]/strings.json.jinja
  - template/custom_components/[[ project_domain ]]/translations/en.json.jinja
autonomous: true
requirements:
  - BACK-06
  - BACK-09

must_haves:
  truths:
    - "Config flow schema includes host, port, and api_key fields"
    - "Config flow validates connection using ApiClient.async_test_connection()"
    - "Options flow includes host, port, and api_key fields with current values as defaults"
    - "Options flow updates entry.data (not just entry.options) so coordinator re-reads on reload"
    - "strings.json and translations/en.json both have api_key labels in config and options sections"
    - "Copier copy produces valid Python and JSON with all fields rendered"
  artifacts:
    - path: "template/custom_components/[[ project_domain ]]/config_flow.py.jinja"
      provides: "Config flow with api_key and real connection validation"
      contains: "CONF_API_KEY"
    - path: "template/custom_components/[[ project_domain ]]/config_flow.py.jinja"
      provides: "Options flow with entry.data update"
      contains: "async_update_entry"
    - path: "template/custom_components/[[ project_domain ]]/strings.json.jinja"
      provides: "Translation keys for api_key field"
      contains: "api_key"
    - path: "template/custom_components/[[ project_domain ]]/translations/en.json.jinja"
      provides: "English translations for api_key field"
      contains: "api_key"
  key_links:
    - from: "template/custom_components/[[ project_domain ]]/config_flow.py.jinja"
      to: "template/custom_components/[[ project_domain ]]/api.py.jinja"
      via: "from .api import ApiClient, CannotConnectError, InvalidAuthError"
      pattern: "from \\.api import"
    - from: "template/custom_components/[[ project_domain ]]/config_flow.py.jinja"
      to: "homeassistant.const"
      via: "CONF_HOST, CONF_PORT, CONF_API_KEY imports"
      pattern: "from homeassistant\\.const import CONF_HOST, CONF_PORT, CONF_API_KEY"
    - from: "template/custom_components/[[ project_domain ]]/strings.json.jinja"
      to: "template/custom_components/[[ project_domain ]]/translations/en.json.jinja"
      via: "identical key structure"
      pattern: "api_key"
---

<objective>
Complete config flow and options flow with API key support and real connection validation; add api_key translation strings; smoke test the full template.

Purpose: BACK-06 requires options flow to reconfigure host/port/API key after setup. BACK-09 requires strings.json and translations/en.json to cover all flow fields including api_key. This plan also runs a copier copy smoke test to validate the complete phase output.

Output: Updated config_flow.py.jinja, strings.json.jinja, translations/en.json.jinja
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-backend-core/03-RESEARCH.md
@.planning/phases/03-backend-core/03-01-SUMMARY.md

@template/custom_components/[[ project_domain ]]/config_flow.py.jinja
@template/custom_components/[[ project_domain ]]/strings.json.jinja
@template/custom_components/[[ project_domain ]]/translations/en.json.jinja
@copier.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update config_flow.py.jinja with api_key and real validation</name>
  <files>
    template/custom_components/[[ project_domain ]]/config_flow.py.jinja
  </files>
  <action>
Read existing config_flow.py.jinja then update it with the following changes.

IMPORTANT: This is a Copier template file using custom delimiters:
- Variables: [[ variable_name ]]
- Python braces `{}` are LITERAL
- Do NOT use {{ }} for Python dicts -- just use { } directly

Changes to make:

1. UPDATE imports:
   - Change `from homeassistant.const import CONF_HOST, CONF_PORT` to `from homeassistant.const import CONF_HOST, CONF_PORT, CONF_API_KEY` (add CONF_API_KEY)
   - ADD: `from homeassistant.helpers.aiohttp_client import async_get_clientsession`
   - ADD: `from .api import ApiClient, CannotConnectError as ApiCannotConnect, InvalidAuthError as ApiInvalidAuth`
   - REMOVE: `from .const import DEFAULT_PORT, DOMAIN` and replace with `from .const import DEFAULT_PORT, DOMAIN` (keep as-is -- no CONF_* imports from .const since they're removed)

2. UPDATE `STEP_USER_DATA_SCHEMA` to add CONF_API_KEY:
   ```
   STEP_USER_DATA_SCHEMA = vol.Schema(
       {
           vol.Required(CONF_HOST): str,
           vol.Required(CONF_PORT, default=DEFAULT_PORT): int,
           vol.Required(CONF_API_KEY): str,
       }
   )
   ```

3. UPDATE `_async_validate_connection` to use ApiClient:
   - Change signature to `async def _async_validate_connection(hass: HomeAssistant, user_input: dict) -> None:` (add `hass` parameter)
   - Replace the TODO body with:
     ```
     session = async_get_clientsession(hass)
     client = ApiClient(
         host=user_input[CONF_HOST],
         port=user_input[CONF_PORT],
         api_key=user_input[CONF_API_KEY],
         session=session,
     )
     try:
         await client.async_test_connection()
     except ApiCannotConnect as err:
         raise CannotConnect from err
     except ApiInvalidAuth as err:
         raise InvalidAuth from err
     ```
   - Keep the `CannotConnect` and `InvalidAuth` exception classes in config_flow.py (they are the HA convention for config flow error mapping). The api.py exceptions are aliased on import to avoid name collision.

4. UPDATE `async_step_user` to pass `self.hass` to validation:
   - Change `await _async_validate_connection(user_input)` to `await _async_validate_connection(self.hass, user_input)`

5. UPDATE `OptionsFlowHandler`:
   - Keep `class OptionsFlowHandler(OptionsFlow):` (NOT OptionsFlowWithReload -- template targets HA 2025.7.0 minimum; OptionsFlowWithReload requires 2025.8+. Using OptionsFlow per compatibility decision.)
   - In `async_step_init`, when `user_input is not None`:
     a. Update entry.data with the new values BEFORE creating the entry:
        ```
        self.hass.config_entries.async_update_entry(
            self.config_entry, data={**self.config_entry.data, **user_input}
        )
        ```
     b. Then return `self.async_create_entry(data={})`
        Note: Pass empty data dict since we updated entry.data directly. The options flow "data" argument stores into entry.options -- we don't need it since we put connection details in entry.data.
   - Add CONF_API_KEY to the options form schema:
     ```
     data_schema=vol.Schema(
         {
             vol.Optional(
                 CONF_HOST,
                 default=self.config_entry.data.get(CONF_HOST, ""),
             ): str,
             vol.Optional(
                 CONF_PORT,
                 default=self.config_entry.data.get(CONF_PORT, DEFAULT_PORT),
             ): int,
             vol.Optional(
                 CONF_API_KEY,
                 default=self.config_entry.data.get(CONF_API_KEY, ""),
             ): str,
         }
     ),
     ```

IMPORTANT: Do NOT define `__init__` on OptionsFlowHandler. Do NOT pass `config_entry` to `OptionsFlowHandler()` constructor. The base class injects it. (Decision from SCAF-06, already correct in template.)

Keep the `CannotConnect` and `InvalidAuth` exception classes. Keep the `@staticmethod @callback async_get_options_flow` method. Keep `VERSION = 1`.
  </action>
  <verify>
Verify config_flow.py.jinja contains:
- `from homeassistant.const import CONF_HOST, CONF_PORT, CONF_API_KEY`
- `from .api import ApiClient, CannotConnectError as ApiCannotConnect, InvalidAuthError as ApiInvalidAuth`
- `from homeassistant.helpers.aiohttp_client import async_get_clientsession`
- `vol.Required(CONF_API_KEY): str` in STEP_USER_DATA_SCHEMA
- `_async_validate_connection(hass: HomeAssistant, user_input` (hass param added)
- `ApiClient(` in _async_validate_connection body
- `await client.async_test_connection()`
- `except ApiCannotConnect` and `except ApiInvalidAuth` clauses
- `_async_validate_connection(self.hass, user_input)` in async_step_user
- `async_update_entry(self.config_entry, data={**self.config_entry.data, **user_input})` in options flow
- `vol.Optional(CONF_API_KEY` in options flow schema
- Does NOT have `OptionsFlowHandler.__init__`
- Does NOT import CONF_API_KEY from .const
  </verify>
  <done>
Config flow includes CONF_API_KEY field, validates connection via ApiClient, options flow updates entry.data directly for coordinator to re-read on reload.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add api_key to strings and translations, then smoke test</name>
  <files>
    template/custom_components/[[ project_domain ]]/strings.json.jinja
    template/custom_components/[[ project_domain ]]/translations/en.json.jinja
  </files>
  <action>
**Part A: Update strings.json.jinja and translations/en.json.jinja**

Read both files. They must be IDENTICAL in structure (hassfest validates this).

Add `"api_key": "API Key"` to BOTH:
1. `config.step.user.data` section (after "port")
2. `options.step.init.data` section (after "port")

The final structure for BOTH files must be:
```json
{
  "config": {
    "step": {
      "user": {
        "title": "Connect to Service",
        "description": "Enter the connection details for your service.",
        "data": {
          "host": "Host",
          "port": "Port",
          "api_key": "API Key"
        }
      }
    },
    "error": {
      "cannot_connect": "Failed to connect",
      "invalid_auth": "Invalid authentication",
      "unknown": "Unexpected error"
    },
    "abort": {
      "already_configured": "Service is already configured"
    }
  },
  "options": {
    "step": {
      "init": {
        "title": "Update Service Settings",
        "data": {
          "host": "Host",
          "port": "Port",
          "api_key": "API Key"
        }
      }
    }
  }
}
```

These are pure JSON files (no Copier [[ ]] variables needed in string values). Write them byte-for-byte identical.

**Part B: Smoke test with copier copy**

After writing the files, run a copier copy to validate the complete template:

```bash
cd /tmp && rm -rf smoke_test_03 && copier copy --defaults --data project_domain=test_integration --data project_name="Test Integration" --data author_name=testuser --data documentation_url="https://example.com" --data issue_tracker_url="https://example.com/issues" /home/dab/Projects/ha-hacs-template /tmp/smoke_test_03
```

Then verify the generated output:
1. `cat /tmp/smoke_test_03/custom_components/test_integration/api.py` -- must contain `class ApiClient` with no Jinja2 artifacts
2. `cat /tmp/smoke_test_03/custom_components/test_integration/coordinator.py` -- must contain `self.client = ApiClient(`
3. `cat /tmp/smoke_test_03/custom_components/test_integration/sensor.py` -- must contain `PARALLEL_UPDATES = 0` and `DeviceEntryType.SERVICE`
4. `cat /tmp/smoke_test_03/custom_components/test_integration/config_flow.py` -- must contain `CONF_API_KEY` and `ApiClient(`
5. `cat /tmp/smoke_test_03/custom_components/test_integration/strings.json` -- must contain `"api_key": "API Key"`
6. `cat /tmp/smoke_test_03/custom_components/test_integration/translations/en.json` -- same api_key check
7. `cat /tmp/smoke_test_03/custom_components/test_integration/const.py` -- must NOT contain CONF_API_KEY
8. `python3 -c "import ast; ast.parse(open('/tmp/smoke_test_03/custom_components/test_integration/api.py').read()); print('api.py: valid')"` -- all Python files must parse
9. Same ast.parse for coordinator.py, sensor.py, config_flow.py, __init__.py, const.py
10. `python3 -c "import json; json.load(open('/tmp/smoke_test_03/custom_components/test_integration/strings.json')); print('strings.json: valid')"` -- JSON must parse
11. Same json.load for translations/en.json, manifest.json
12. `python3 -c "import json; d=json.load(open('/tmp/smoke_test_03/custom_components/test_integration/strings.json')); e=json.load(open('/tmp/smoke_test_03/custom_components/test_integration/translations/en.json')); assert d==e, 'MISMATCH'; print('strings match')"` -- strings.json and translations/en.json must be identical

If any check fails, diagnose and fix the template file causing the issue.
  </action>
  <verify>
All smoke test checks pass:
- All 6 Python files parse with ast.parse
- All 3 JSON files parse with json.load
- strings.json == translations/en.json
- Generated config_flow.py contains CONF_API_KEY and ApiClient
- Generated sensor.py contains PARALLEL_UPDATES = 0 and DeviceEntryType.SERVICE
- Generated api.py contains class ApiClient with no template artifacts
  </verify>
  <done>
strings.json.jinja and translations/en.json.jinja both have api_key labels in config and options sections. Copier smoke test confirms all template files render to valid Python/JSON with no Jinja2 artifacts.
  </done>
</task>

</tasks>

<verification>
- Config flow has CONF_API_KEY in both config and options schemas (BACK-06)
- Config flow validates connection via ApiClient.async_test_connection() (BACK-06)
- Options flow updates entry.data (not entry.options) so coordinator re-reads on reload (BACK-06)
- strings.json and translations/en.json both have api_key in config.step.user.data and options.step.init.data (BACK-09)
- strings.json and translations/en.json are structurally identical (hassfest requirement)
- Copier copy produces valid Python and JSON files (integration test)
</verification>

<success_criteria>
- Config flow collects host, port, and API key with real connection validation
- Options flow allows changing all three connection fields and updates entry.data
- Translation files are complete and identical in structure
- Copier copy smoke test passes: all Python files parse, all JSON files parse, no Jinja2 artifacts
</success_criteria>

<output>
After completion, create `.planning/phases/03-backend-core/03-03-SUMMARY.md`
</output>
