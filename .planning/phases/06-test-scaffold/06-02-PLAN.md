---
phase: 06-test-scaffold
plan: 02
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - template/tests/test_config_flow.py.jinja
  - template/tests/test_coordinator.py.jinja
autonomous: true
requirements:
  - TEST-02
  - TEST-03

must_haves:
  truths:
    - "test_config_flow.py covers successful setup flow creating an entry with host/port/api_key data"
    - "test_config_flow.py covers CannotConnect error displayed back to user on connection failure"
    - "test_config_flow.py covers duplicate entry abort when same host:port already configured"
    - "test_config_flow.py covers options flow saving updated values to entry.data"
    - "test_coordinator.py covers successful data refresh from mocked API client"
    - "test_coordinator.py covers failed refresh raising UpdateFailed when API is unreachable"
  artifacts:
    - path: "template/tests/test_config_flow.py.jinja"
      provides: "Config flow test coverage (4 test cases)"
      contains: "test_form"
    - path: "template/tests/test_coordinator.py.jinja"
      provides: "Coordinator test coverage (2 test cases)"
      contains: "test_coordinator_update"
  key_links:
    - from: "template/tests/test_config_flow.py.jinja"
      to: "config_flow._async_validate_connection"
      via: "unittest.mock.patch on the validation function"
      pattern: "patch.*config_flow._async_validate_connection"
    - from: "template/tests/test_coordinator.py.jinja"
      to: "coordinator.ApiClient.async_get_data"
      via: "unittest.mock.patch on the API client method"
      pattern: "patch.*coordinator.ApiClient.async_get_data"
    - from: "template/tests/test_config_flow.py.jinja"
      to: "conftest.mock_setup_entry"
      via: "fixture parameter in test functions"
      pattern: "mock_setup_entry.*AsyncMock"
---

<objective>
Create the always-on test template files: test_config_flow.py covering 4 scenarios (successful setup, connection error, duplicate abort, options flow), and test_coordinator.py covering coordinator refresh with mocked API client.

Purpose: Every generated project ships with working config flow and coordinator tests that validate the core integration functionality.
Output: Two .jinja test template files that Copier renders into passing pytest test modules.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-test-scaffold/06-RESEARCH.md
@.planning/phases/06-test-scaffold/06-01-SUMMARY.md
@template/custom_components/[[ project_domain ]]/config_flow.py.jinja
@template/custom_components/[[ project_domain ]]/coordinator.py.jinja
@template/custom_components/[[ project_domain ]]/const.py.jinja
@template/custom_components/[[ project_domain ]]/api.py.jinja
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_config_flow.py.jinja with 4 test cases</name>
  <files>template/tests/test_config_flow.py.jinja</files>
  <action>
Create `template/tests/test_config_flow.py.jinja` with four test cases matching the HA canonical scaffold pattern.

**Imports section:**
```python
"""Tests for [[ project_name ]] config flow."""

from unittest.mock import AsyncMock, patch

from homeassistant import config_entries
from homeassistant.const import CONF_API_KEY, CONF_HOST, CONF_PORT
from homeassistant.core import HomeAssistant
from homeassistant.data_entry_flow import FlowResultType

from pytest_homeassistant_custom_component.common import MockConfigEntry

from custom_components.[[ project_domain ]].config_flow import CannotConnect
from custom_components.[[ project_domain ]].const import DOMAIN
```

**Test 1: Successful setup (test_form)**
- Init flow with SOURCE_USER context
- Assert initial result is FlowResultType.FORM with no errors
- Patch `custom_components.[[ project_domain ]].config_flow._async_validate_connection` to return None
- Configure flow with `{CONF_HOST: "192.168.1.100", CONF_PORT: 8080, CONF_API_KEY: "test-key"}`
- Call `await hass.async_block_till_done()` (required for mock_setup_entry assertion)
- Assert result is FlowResultType.CREATE_ENTRY
- Assert result["data"] matches the submitted user_input
- Assert `len(mock_setup_entry.mock_calls) == 1`
- Test function takes `hass: HomeAssistant, mock_setup_entry: AsyncMock` parameters (mock_setup_entry from conftest)

**Test 2: Connection failure (test_form_cannot_connect)**
- Init flow, then patch `_async_validate_connection` with `side_effect=CannotConnect`
- Configure flow with valid input
- Assert result is FlowResultType.FORM (stays on form)
- Assert result["errors"] == {"base": "cannot_connect"}

**Test 3: Duplicate abort (test_form_duplicate_abort)**
- Create a MockConfigEntry with domain=DOMAIN, unique_id="192.168.1.100:8080", and add to hass
- Init flow, patch `_async_validate_connection` to return None
- Configure with same host:port
- Assert result is FlowResultType.ABORT
- Assert result["reason"] == "already_configured"

**Test 4: Options flow (test_options_flow)**
- Create MockConfigEntry with domain=DOMAIN, data={CONF_HOST, CONF_PORT, CONF_API_KEY} and add to hass
- Init options flow via `hass.config_entries.options.async_init(entry.entry_id)` (NOT flow.async_init)
- Assert initial result is FlowResultType.FORM
- Configure with updated values (e.g., new api_key)
- Assert result is FlowResultType.CREATE_ENTRY
- Assert `entry.data[CONF_API_KEY] == "new-key"` — options flow writes to entry.data (NOT entry.options, per Phase 3 decision, Pitfall 4 from research)

CRITICAL mock target: Always patch `custom_components.[[ project_domain ]].config_flow._async_validate_connection` — this is where the function is CALLED, not where ApiClient is defined (Pitfall 2 from research).

All Copier variables use `[[ ]]` delimiters. Python dict literals `{}`, f-strings `f""`, and type hints use raw braces — safe because _envops custom delimiters prevent brace collision.
  </action>
  <verify>
- `grep "test_form" template/tests/test_config_flow.py.jinja` returns all 4 test function names
- `grep "FlowResultType.CREATE_ENTRY\|FlowResultType.FORM\|FlowResultType.ABORT" template/tests/test_config_flow.py.jinja` confirms all 3 result types asserted
- `grep "config_flow._async_validate_connection" template/tests/test_config_flow.py.jinja` confirms correct patch target
- `grep "entry.data\[CONF_API_KEY\]" template/tests/test_config_flow.py.jinja` confirms options flow asserts against entry.data (not entry.options)
  </verify>
  <done>test_config_flow.py.jinja contains 4 test cases (successful setup, CannotConnect error, duplicate abort, options flow) with correct mock targets and assertions</done>
</task>

<task type="auto">
  <name>Task 2: Create test_coordinator.py.jinja with refresh tests</name>
  <files>template/tests/test_coordinator.py.jinja</files>
  <action>
Create `template/tests/test_coordinator.py.jinja` with two test cases.

**Imports section:**
```python
"""Tests for [[ project_name ]] coordinator."""

from unittest.mock import AsyncMock, patch

from homeassistant.const import CONF_API_KEY, CONF_HOST, CONF_PORT
from homeassistant.core import HomeAssistant
from homeassistant.helpers.update_coordinator import UpdateFailed

from pytest_homeassistant_custom_component.common import MockConfigEntry

from custom_components.[[ project_domain ]].api import CannotConnectError
from custom_components.[[ project_domain ]].const import DOMAIN
from custom_components.[[ project_domain ]].coordinator import TemplateCoordinator
```

**Test 1: Successful refresh (test_coordinator_update)**
- Create MockConfigEntry with domain=DOMAIN, data={CONF_HOST: "192.168.1.100", CONF_PORT: 8080, CONF_API_KEY: "test-key"} and add to hass
- Define mock_data = {"sensor_value": 42, "status": "ok"}
- Patch `custom_components.[[ project_domain ]].coordinator.ApiClient.async_get_data` with AsyncMock returning mock_data
- Inside the patch context: create `TemplateCoordinator(hass, entry)`, call `await coordinator.async_refresh()`
- Assert `coordinator.data == mock_data`

**Test 2: Failed refresh (test_coordinator_update_failed)**
- Same MockConfigEntry setup
- Patch `coordinator.ApiClient.async_get_data` with `side_effect=CannotConnectError("Connection refused")`
- Create coordinator, call `await coordinator.async_refresh()`
- Use pytest.raises(UpdateFailed) to assert that CannotConnectError is translated to UpdateFailed
- This validates the error translation in coordinator._async_update_data

CRITICAL mock target: Patch `custom_components.[[ project_domain ]].coordinator.ApiClient.async_get_data` — the coordinator module is where ApiClient is imported and used (Pitfall 2 from research).

Note: TemplateCoordinator is the actual class name from coordinator.py.jinja — NOT a Copier variable. It is hardcoded in the template.
  </action>
  <verify>
- `grep "test_coordinator_update" template/tests/test_coordinator.py.jinja` returns both test function names
- `grep "coordinator.ApiClient.async_get_data" template/tests/test_coordinator.py.jinja` confirms correct patch target
- `grep "UpdateFailed" template/tests/test_coordinator.py.jinja` confirms error translation test
- `grep "TemplateCoordinator" template/tests/test_coordinator.py.jinja` confirms correct class name reference
  </verify>
  <done>test_coordinator.py.jinja contains 2 test cases (successful refresh, failed refresh with UpdateFailed) using correct mock targets and TemplateCoordinator class name</done>
</task>

</tasks>

<verification>
1. Both test template files exist under template/tests/:
   - `template/tests/test_config_flow.py.jinja`
   - `template/tests/test_coordinator.py.jinja`
2. Config flow tests cover all 4 required scenarios from TEST-02
3. Coordinator tests cover refresh success and failure from TEST-03
4. All mock patches target the correct module path (where function is called, not defined)
5. Options flow test asserts against entry.data (not entry.options)
6. All Copier variables use `[[ ]]` delimiters
7. No raw `{{ }}` Jinja2 syntax in any file
</verification>

<success_criteria>
- test_config_flow.py.jinja has 4 passing test case functions
- test_coordinator.py.jinja has 2 passing test case functions
- Mock targets follow the "patch where called" principle
- Options flow test checks entry.data per Phase 3 decision
- TEST-02 and TEST-03 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/06-test-scaffold/06-02-SUMMARY.md`
</output>
