---
phase: 05-conditional-patterns
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - "template/custom_components/[[ project_domain ]]/[% if use_websocket %]websocket.py[% endif %].jinja"
  - "template/custom_components/[[ project_domain ]]/[% if use_services %]services.py[% endif %].jinja"
  - "template/custom_components/[[ project_domain ]]/[% if use_services %]services.yaml[% endif %].jinja"
  - "template/custom_components/[[ project_domain ]]/manifest.json.jinja"
autonomous: true
requirements:
  - COND-01
  - COND-02
  - COND-06

must_haves:
  truths:
    - "WebSocket stub replaced with working async command handler using @websocket_command + @async_response decorators"
    - "Services stub replaced with working SupportsResponse.OPTIONAL handler and async_register_services callback"
    - "services.yaml conditional template file exists and documents the query service"
    - "manifest.json conditionally includes websocket_api in dependencies when use_websocket is true"
  artifacts:
    - path: "template/custom_components/[[ project_domain ]]/[% if use_websocket %]websocket.py[% endif %].jinja"
      provides: "WebSocket command handler with async_setup_websocket registration function"
      contains: "websocket_api.async_register_command"
    - path: "template/custom_components/[[ project_domain ]]/[% if use_services %]services.py[% endif %].jinja"
      provides: "Service handler with SupportsResponse.OPTIONAL"
      contains: "async_register_services"
    - path: "template/custom_components/[[ project_domain ]]/[% if use_services %]services.yaml[% endif %].jinja"
      provides: "Service YAML definition for hassfest"
      contains: "query"
    - path: "template/custom_components/[[ project_domain ]]/manifest.json.jinja"
      provides: "Conditional websocket_api dependency"
      contains: "websocket_api"
  key_links:
    - from: "websocket.py.jinja"
      to: "const.py.jinja"
      via: "DOMAIN import for WS command type prefix"
      pattern: "from .const import DOMAIN"
    - from: "services.py.jinja"
      to: "const.py.jinja"
      via: "DOMAIN import for service registration"
      pattern: "from .const import DOMAIN"
    - from: "manifest.json.jinja"
      to: "copier.yml"
      via: "use_websocket boolean flag controls websocket_api dependency"
      pattern: "use_websocket"
---

<objective>
Implement WebSocket command handler and service action handler conditional templates, plus conditional manifest dependency.

Purpose: Fill in the WebSocket and services stub files from Phase 2 with working, community-quality implementation code. Create the missing services.yaml conditional template. Add conditional websocket_api dependency to manifest.json.

Output: Three filled conditional template files (websocket.py, services.py, services.yaml) and updated manifest.json with conditional dependency.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-conditional-patterns/05-RESEARCH.md

# Existing files to modify
@template/custom_components/[[ project_domain ]]/manifest.json.jinja
@template/custom_components/[[ project_domain ]]/const.py.jinja
@template/custom_components/[[ project_domain ]]/coordinator.py.jinja
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WebSocket command handler and service action handler</name>
  <files>
    template/custom_components/[[ project_domain ]]/[% if use_websocket %]websocket.py[% endif %].jinja
    template/custom_components/[[ project_domain ]]/[% if use_services %]services.py[% endif %].jinja
  </files>
  <action>
    Replace the websocket.py stub with a complete async WebSocket command handler following the HA core hassio/websocket_api.py pattern from research:
    - Import websocket_api, voluptuous, HomeAssistant, callback from HA
    - Import DOMAIN from .const
    - Define `WS_TYPE_GET_DATA = f"{DOMAIN}/get_data"` command type constant
    - Create `websocket_get_data` async handler with decorators in CORRECT order: `@websocket_api.websocket_command({vol.Required("type"): WS_TYPE_GET_DATA})` outermost, `@websocket_api.async_response` next
    - Handler signature: `async def websocket_get_data(hass: HomeAssistant, connection: websocket_api.ActiveConnection, msg: dict[str, Any]) -> None`
    - Handler body: look up config entries via `hass.config_entries.async_entries(DOMAIN)`, send error if none, otherwise get coordinator from `entries[0].runtime_data.coordinator` and `connection.send_result(msg["id"], coordinator.data or {})`
    - Create `async_setup_websocket(hass: HomeAssistant) -> None` decorated with `@callback`, which calls `websocket_api.async_register_command(hass, websocket_get_data)`
    - Use Copier [[ ]] for project_name in docstrings

    Replace the services.py stub with a complete service handler following the HA developer docs pattern from research:
    - Import ServiceCall, ServiceResponse, SupportsResponse, callback from homeassistant.core
    - Import config_validation as cv, voluptuous
    - Import DOMAIN from .const
    - Define `SERVICE_QUERY = "query"` constant and `SERVICE_SCHEMA = vol.Schema({vol.Required("query"): cv.string})`
    - Create `async def _async_handle_query(call: ServiceCall) -> ServiceResponse` that returns `{"query": call.data["query"], "results": []}` when `call.return_response` is True, else None
    - Create `@callback def async_register_services(hass: HomeAssistant) -> None` that calls `hass.services.async_register(DOMAIN, SERVICE_QUERY, _async_handle_query, schema=SERVICE_SCHEMA, supports_response=SupportsResponse.OPTIONAL)`
    - Use Copier [[ ]] for project_name in docstrings

    CRITICAL: Both files use standard Python braces — NO escaping needed because the project's _envops uses [[ ]]/[% %] delimiters (Python braces are invisible to Copier).
  </action>
  <verify>
    Verify both files have valid Python syntax by checking with `python3 -c "import ast; ast.parse(open('...').read())"` after temporarily replacing [[ project_name ]] with a literal string. Check that websocket.py contains `@websocket_api.websocket_command` and `@websocket_api.async_response` in correct order. Check that services.py contains `SupportsResponse.OPTIONAL` and `async_register_services`.
  </verify>
  <done>
    websocket.py.jinja contains a working async WebSocket command handler with correct decorator order and async_setup_websocket registration function. services.py.jinja contains a working SupportsResponse.OPTIONAL service handler with async_register_services callback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create services.yaml conditional template and add manifest.json conditional dependency</name>
  <files>
    template/custom_components/[[ project_domain ]]/[% if use_services %]services.yaml[% endif %].jinja
    template/custom_components/[[ project_domain ]]/manifest.json.jinja
  </files>
  <action>
    CREATE a new conditional template file `[% if use_services %]services.yaml[% endif %].jinja` in the template domain directory. This file does NOT exist yet (no stub was created in Phase 2). Content:
    ```yaml
    query:
      description: "Query the [[ project_name ]] service and optionally return results."
      fields:
        query:
          required: true
          description: "The query string to send."
          example: "search term"
          selector:
            text:
      response:
        optional: true
    ```
    Note: The filename pattern `[% if use_services %]services.yaml[% endif %].jinja` follows the established conditional file naming convention from Phase 2. The content uses `[[ project_name ]]` for Copier substitution.

    UPDATE manifest.json.jinja to conditionally include `websocket_api` in the dependencies array. Change:
    ```json
    "dependencies": ["frontend"],
    ```
    To:
    ```json
    "dependencies": ["frontend"[% if use_websocket %], "websocket_api"[% endif %]],
    ```
    This is a Jinja2 block inside a JSON value — valid because the file is a .jinja template rendered by Copier. The comma placement ensures valid JSON: when use_websocket=false, result is `["frontend"]`; when true, result is `["frontend", "websocket_api"]`.
  </action>
  <verify>
    Verify services.yaml.jinja file exists with correct conditional filename pattern. Verify manifest.json.jinja contains the conditional websocket_api dependency line. Check that when the [% if %] block is both true and false, the resulting JSON is valid (mental check: `["frontend"]` and `["frontend", "websocket_api"]` are both valid JSON arrays).
  </verify>
  <done>
    services.yaml conditional template exists with query service definition using [[ project_name ]] substitution. manifest.json conditionally includes websocket_api in dependencies array gated by use_websocket flag.
  </done>
</task>

</tasks>

<verification>
1. websocket.py.jinja has complete async WebSocket handler with @websocket_command + @async_response decorators and async_setup_websocket function
2. services.py.jinja has complete SupportsResponse.OPTIONAL handler with async_register_services function
3. services.yaml.jinja is a NEW conditional file with correct filename pattern and query service definition
4. manifest.json.jinja conditionally includes "websocket_api" in dependencies when use_websocket is true
5. All template files use [[ ]] for variable substitution and standard Python braces for code (no escaping needed)
</verification>

<success_criteria>
- WebSocket module provides async_setup_websocket(hass) callable for __init__.py wiring
- Services module provides async_register_services(hass) callable for __init__.py wiring
- services.yaml exists as conditional file matching services.py conditional pattern
- manifest.json properly renders with or without websocket_api based on Copier flag
</success_criteria>

<output>
After completion, create `.planning/phases/05-conditional-patterns/05-01-SUMMARY.md`
</output>
